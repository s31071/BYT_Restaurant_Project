## What has been implemented? 
In our implementation, each class uses a clear and consistent approach to defining its attributes based on the UML model. Basic attributes (such as strings, numbers, or enums) are implemented as private fields with validation inside setters or constructors to ensure data correctness (e.g., checking price > 0, non-empty strings, valid dates). Complex attributes are represented using full objects, such as Address inside Person or Product inside ProductOrder, which enforces composition and allows validation to propagate between dependent classes. Multi-value attributes (e.g., a list of products in ProductOrder, or a waiterâ€™s assigned tables) are implemented using List<T> with controlled add/remove methods to maintain integrity and avoid external modification. Optional attributes (such as an optional email or delivery date) are implemented using nullable fields with validation that only applies when a value is provided. Derived attributes (e.g., total order weight, total price, number of items) are not stored directly; instead, they are computed dynamically using getter methods to avoid inconsistency between stored and calculated values. Class attributes (static) follow the guidelines from the notes: constants use static final, while shared counters or mappings use static with validation protected by private setters.

To support class extent persistence, each persistent class maintains a private static List<ClassName> extent that stores every created instance. The extent is updated inside constructors or factory methods to ensure that objects cannot exist outside the registered set. For saving and loading extents, we use Java serialization exactly as recommended in the assignment notes. Each class implements a pair of static methods: writeExtent(ObjectOutputStream oos) and readExtent(ObjectInputStream ois), allowing all instances to be serialized and deserialized. A global persistence controller called ExtentToolBox invokes these methods for all classes when saving or loading the application state. This approach ensures that the full object graph is preserved across program executions, maintains referential integrity, and matches the UML requirement for extent persistence.
