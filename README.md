## What has been implemented? 
In our implementation, each class uses a clear and consistent approach to defining its attributes based on the UML model. Basic attributes (such as strings, numbers, or enums) are implemented as private fields with validation inside setters or constructors to ensure data correctness (e.g., checking price > 0, non-empty strings, valid dates). Complex attributes are represented using full objects, such as Address inside Person or Invoice. Multi-value attributes (e.g., a list of products in ProductOrder, or a waiterâ€™s assigned tables) are implemented using List<T> with controlled add/remove methods to maintain integrity and avoid external modification. Optional attributes (such as delivery date or tip) are implemented using nullable fields (for example using Double instead of double in Tip in Receipt Class) with validation that only applies when a value is provided. Derived attributes (e.g., total order weight, total price, salary) are not stored directly; instead, they are computed dynamically using getter methods to avoid inconsistency between stored and calculated values. Class attributes (static) follow the guidelines from the diagram: constants use static final, while shared counters or mappings use static with validation protected by private setters. The project also implements a qualified association, which is modeled using a HashMap - specifically between Table and Order classes. 

To support class extent persistence, each persistent class maintains a private static List<ClassName> extent that stores every created instance. The extent is updated inside constructors or factory methods to ensure that objects cannot exist outside the registered set. For saving and loading extents, we use Java serialization. Each class implements a pair of static methods: writeExtent(XMLEncoder objectOutputStream) and readExtent(XMLDecoder objectInputStream), allowing all instances to be serialized and deserialized. ClearExtent method has also been added in order to properly clear extents before our tests. A global persistence controller called ExtentToolBox invokes these methods for all classes when saving or loading the application state. This approach ensures that the full object graph is preserved across program executions, maintains referential integrity, and matches the UML requirement for extent persistence.
